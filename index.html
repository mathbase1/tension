<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Civil Engineering – Statics: Two‑Member Tension Joints</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script id="MathJax-script" async
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <style>
    :root{
      --accent:#6a5cff; --accent2:#00c2ff; --ink:#0f172a; --muted:#55607a;
      --success:#2e7d32; --error:#e53935; --surface:#ffffff; --field-w:10.8rem;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial,sans-serif;
      margin:0;color:var(--ink);
      background:
        radial-gradient(1200px 600px at 10% -10%, #dfe8ff, transparent 60%),
        radial-gradient(1200px 600px at 110% 10%, #ccfbff, transparent 60%),
        linear-gradient(180deg,#f5f8ff 0%, #f0fbff 50%, #eef3ff 100%);
      min-height:100vh; overflow-x:hidden;
    }
    h1{
      margin:0.5rem 0 0.2rem;text-align:center;
      font-size:1.42rem;font-weight:900;
      background:linear-gradient(90deg,var(--accent),var(--accent2));
      -webkit-background-clip:text;background-clip:text;color:transparent;
      letter-spacing:.2px
    }
    p.lede{max-width:980px;margin:0.15rem auto 0.4rem;text-align:center;color:#1f2a44}

    .logo{
      position:absolute;top:10px;left:10px;width:96px;height:96px;border-radius:14px;
      box-shadow:0 6px 18px rgba(0,0,0,.15);
      background:#fff;border:1px solid rgba(106,92,255,.25);
      display:grid;place-items:center;overflow:hidden
    }
    .logo svg{width:92px;height:92px}

    .topbar{
      max-width:980px;margin:0.1rem auto 0.4rem;display:flex;gap:0.6rem;
      justify-content:space-between;align-items:center;padding:0 0.6rem
    }
    .badge{
      background:#fff;border:1px solid rgba(106,92,255,.25);border-radius:14px;
      padding:0.35rem 0.55rem;font-weight:800;min-width:110px;text-align:center;
      box-shadow:0 3px 10px rgba(106,92,255,.08)
    }
    .badge small{display:block;font-weight:600;color:var(--muted);margin-top:2px;font-size:.8rem}
    .fsBtn{
      border:1px solid rgba(0,194,255,.5);background:linear-gradient(180deg,#ffffff,#f3fcff);
      border-radius:12px;padding:.45rem .7rem;font-weight:900;cursor:pointer;color:#0b3d4a;
      box-shadow:0 3px 10px rgba(0,194,255,.15)
    }

    .card{
      max-width:980px;margin:0.25rem auto;background:var(--surface);border-radius:16px;
      border:2px solid rgba(106,92,255,.35);
      box-shadow:0 12px 28px rgba(106,92,255,.12), 0 6px 14px rgba(0,0,0,.06);
      padding:0.8rem
    }
    .titleRow{display:flex;justify-content:space-between;align-items:flex-start;gap:1rem}
    .qTitle{font-size:1.08rem;font-weight:900;color:#2c3477;margin:0.05rem 0}
    .qMeta{color:var(--muted);font-size:.93rem}
    .statement{font-size:0.98rem;margin:0.4rem 0 0.5rem}

    details{border:1px solid rgba(106,92,255,.3);border-radius:12px;margin:0.35rem 0;background:#fbfcff}
    summary{cursor:pointer;font-weight:900;color:#2c3477;padding:0.5rem 0.7rem;list-style:none}
    summary::-webkit-details-marker{display:none}
    .hint{padding:0 0.8rem 0.7rem;font-size:.92rem;color:#1f2a44}

    .io{display:grid;gap:0.6rem;margin-top:0.35rem}
    .row{display:grid;grid-template-columns:1.2fr auto auto auto 1fr;align-items:center;gap:.45rem}
    .row label{font-weight:900;color:#1f2a44}
    .unit{
      background:linear-gradient(180deg,#eef4ff,#f7fbff);
      border:1px solid rgba(0,194,255,.35);
      color:#173a56;border-radius:10px;padding:0.3rem 0.55rem;font-weight:900;min-width:6.2rem;text-align:center
    }
    .num{
      width:var(--field-w);text-align:center;border:1px solid rgba(106,92,255,.45);
      border-radius:10px;font-size:1.0rem;padding:.44rem .36rem;background:linear-gradient(180deg,#ffffff,#f6f7ff);
      box-shadow:inset 0 1px 2px rgba(0,0,0,.06)
    }
    .num:focus{outline:none;border-color:var(--accent);box-shadow:0 0 0 3px rgba(106,92,255,.18)}

    .marker{font-size:1.35rem;font-weight:900;min-width:1.7rem;text-align:center}
    .ok{color:#2e7d32; animation:pop .25s ease-out}
    .no{color:#e53935}
    @keyframes pop { 0%{transform:scale(0.85)} 100%{transform:scale(1)} }
    .feedback{font-size:0.92rem;color:#1f2a44}
    .feedback .ans{font-weight:900}

    .controls{display:flex;justify-content:center;gap:.5rem;margin-top:0.55rem;flex-wrap:wrap}
    button.primary{
      background:linear-gradient(90deg,var(--accent),var(--accent2));
      color:#fff;border:none;border-radius:12px;padding:.6rem 1.0rem;font-weight:900;cursor:pointer;
      box-shadow:0 8px 18px rgba(106,92,255,.25)
    }
    button.secondary{
      background:#111827;color:#fff;border:none;border-radius:12px;padding:.6rem 1.0rem;font-weight:900;cursor:pointer
    }
    button.ghost{
      background:linear-gradient(180deg,#ffffff,#f7f9ff);border:1px solid rgba(17,24,39,.25);
      border-radius:12px;padding:.5rem .9rem;font-weight:900;cursor:pointer;color:#111827
    }
    button:disabled{opacity:.6;cursor:not-allowed}
    #progress{font-weight:900;text-align:center;color:#111827;margin:0.12rem 0 0.45rem}

    #endCard{max-width:820px;margin:0.6rem auto;padding:0.8rem;border-radius:14px;background:#fff;border:2px solid #2e7d32;display:none}
    #endCard h3{margin-top:0;color:#1e7a31}
    .wellDone{display:inline-block;background:#eaf7ec;border:1px solid #b9e2bf;color:#1e7a31;padding:.22rem .48rem;border-radius:8px;font-weight:900}

    .fig{
      width:100%;
      height:auto;
      max-width:960px;
      display:block;
      margin:.55rem auto;
      border-radius:12px;
      box-shadow:0 10px 22px rgba(0,0,0,.08);
      background:#fff;
      overflow:visible;
    }

    @media (max-width:680px){
      .row{grid-template-columns:1fr auto auto auto 1fr}
      .num{width:8.6rem}
      .logo{width:84px;height:84px}
    }

    .modal{position:fixed;inset:0;background:rgba(15,23,42,.35);display:flex;align-items:center;justify-content:center;padding:1rem;z-index:999}
    .panel{background:linear-gradient(180deg,#ffffff,#f7f8ff);border-radius:16px;max-width:780px;width:100%;box-shadow:0 18px 40px rgba(17,24,39,.25);border:2px solid rgba(106,92,255,.35)}
    .panel header{padding:0.8rem 1rem;border-bottom:1px solid rgba(106,92,255,.25)}
    .panel .content{padding:0.8rem;display:grid;gap:0.7rem}
    .grid2{display:grid;grid-template-columns:1fr 1fr;gap:0.6rem}
    .field{display:grid;gap:0.3rem}
    .field input[type=text], .field input[type=number], .field select{
      padding:0.5rem .55rem;border:1px solid rgba(106,92,255,.4);border-radius:10px;background:#fff
    }
    .choiceRow{display:flex;gap:.6rem;align-items:center;flex-wrap:wrap}
    .pill{border:1px solid rgba(106,92,255,.45);padding:.32rem .6rem;border-radius:999px;cursor:pointer;font-weight:900;background:#fff}
    .pill input{margin-right:.32rem}
    .panel footer{display:flex;justify-content:space-between;align-items:center;padding:0.7rem 1rem;border-top:1px solid rgba(106,92,255,.25)}
    .muted{color:var(--muted);font-size:.9rem}

    #errBanner{display:none;position:fixed;bottom:10px;left:50%;transform:translateX(-50%);
      background:#fee;border:2px solid #e53935;color:#7f1d1d;padding:.5rem .8rem;border-radius:10px;font-weight:800;z-index:2000}
  </style>
</head>
<body>
  <div class="logo" aria-label="Logo">
    <svg viewBox="0 0 100 100" role="img">
      <defs>
        <linearGradient id="g" x1="0" y1="0" x2="1" y2="1">
          <stop offset="0" stop-color="#6a5cff"/>
          <stop offset="1" stop-color="#00c2ff"/>
        </linearGradient>
      </defs>
      <rect x="6" y="6" width="88" height="88" rx="18" fill="url(#g)" opacity="0.15"/>
      <path d="M18 70 L50 22 L82 70" fill="none" stroke="url(#g)" stroke-width="8" stroke-linecap="round" stroke-linejoin="round"/>
      <circle cx="50" cy="70" r="6.5" fill="url(#g)"/>
      <path d="M22 78 H78" stroke="#0f172a" stroke-width="6" stroke-linecap="round" opacity="0.25"/>
    </svg>
  </div>

  <h1>Statics Worksheet: Two‑Member Tension Joints</h1>
  <p class="lede">
    <strong>All cases are in static equilibrium.</strong><br>
    <strong>Round every answer to 2 decimal places.</strong>
    Marking accepts answers within <strong>±2.00</strong> of the correct value (checked at <strong>0.01</strong> resolution).<br>
    If the correct answer is a whole number, you may enter it without “.00”.
  </p>

  <div class="topbar">
    <div style="display:flex;gap:0.6rem;align-items:center">
      <div class="badge" id="who"><span id="whoName">Student</span><small>Participant</small></div>
      <div class="badge" id="mode"><span id="modeTxt">Timed</span><small>Mode</small></div>
      <div class="badge" id="timer"><span id="timeTxt">—</span><small>Timer</small></div>
      <div class="badge" id="scoreTop"><span id="scoreTopVal">0 / 0</span><small>Score</small></div>
    </div>
    <div class="top-actions">
      <button class="fsBtn" id="fsBtn" title="Toggle full screen">⛶ Full screen</button>
    </div>
  </div>

  <div class="card" id="globalHint">
    <details>
      <summary>Quick note (read once)</summary>
      <div class="hint">
        <ul>
          <li>Each question has <strong>exactly two members</strong> meeting at a joint.</li>
          <li>Angles <strong>θ₁</strong> and <strong>θ₂</strong> are measured from the <strong>dashed reference line</strong> at the joint.</li>
          <li>The external force/weight acts <strong>opposite</strong> to the dashed reference line.</li>
          <li>Questions include a mixture of <strong>cables</strong> and <strong>members (bars/rods)</strong>.</li>
        </ul>
      </div>
    </details>
  </div>

  <div class="card" id="qCard" style="display:none">
    <div class="titleRow">
      <div>
        <div class="qTitle" id="qTitle">Question</div>
        <div class="qMeta">Use the diagram and resolve forces at the joint (static equilibrium).</div>
      </div>
      <div class="qMeta" id="progress">Question 1</div>
    </div>

    <div class="statement" id="statement"></div>

    <div class="io">
      <div class="row">
        <label>Result</label>
        <input class="num" id="ansVal" type="text" inputmode="decimal" autocomplete="off" placeholder="e.g. 12.34">
        <span class="unit" id="unitOut"></span>
        <span class="marker" id="markAns"></span>
        <span class="feedback" id="fbAns"></span>
      </div>
    </div>

    <div class="controls">
      <button class="primary" id="checkBtn">Check</button>
      <button class="ghost" id="nextBtn" disabled>Next</button>
      <button class="secondary" id="newBtn">New questions</button>
    </div>
  </div>

  <div id="endCard">
    <h3>Summary</h3>
    <p class="wellDone" id="endMsg"></p>
    <ul>
      <li><strong>Name:</strong> <span id="sumName"></span></li>
      <li><strong>Mode:</strong> <span id="sumMode"></span></li>
      <li><strong>Score:</strong> <span id="sumScore"></span></li>
      <li><strong>Time used:</strong> <span id="sumTime"></span></li>
    </ul>
    <div style="display:flex;gap:.6rem;justify-content:center;margin-top:.3rem">
      <button class="secondary" id="restartBtn">Restart</button>
    </div>
  </div>

  <div class="modal" id="startModal" style="display:flex">
    <div class="panel">
      <header><h2 style="margin:0;color:#2c3477">Start Worksheet</h2></header>
      <div class="content">
        <div class="field">
          <label for="nameInput"><strong>Your name</strong></label>
          <input id="nameInput" type="text" placeholder="Type your name…" autocomplete="name">
        </div>

        <div class="field">
          <label><strong>Mode</strong></label>
          <div class="choiceRow">
            <label class="pill"><input type="radio" name="mode" value="timed" checked>Timed</label>
            <label class="pill"><input type="radio" name="mode" value="target">Target</label>
          </div>
        </div>

        <div class="grid2">
          <div class="field" id="timedField" style="display:block">
            <label><strong>Time limit</strong></label>
            <div class="choiceRow">
              <label class="pill"><input type="radio" name="tlimit" value="600">10 minutes</label>
              <label class="pill"><input type="radio" name="tlimit" value="1200" checked>20 minutes</label>
              <label class="pill"><input type="radio" name="tlimit" value="1800">30 minutes</label>
              <label class="pill"><input type="radio" name="tlimit" value="0">Unlimited</label>
            </div>
          </div>

          <div class="field" id="targetField" style="display:none">
            <label for="targetInput"><strong>Target (correct answers to finish)</strong></label>
            <input id="targetInput" type="number" min="1" max="1000" step="1" value="10">
          </div>
        </div>

        <div class="grid2">
          <div class="field">
            <label for="qtyInput"><strong>Total questions (per set)</strong></label>
            <select id="qtyInput">
              <option value="8">8</option>
              <option value="10" selected>10</option>
              <option value="12">12</option>
              <option value="15">15</option>
            </select>
          </div>
          <div class="field">
            <div class="muted">
              Includes: <strong>two‑member joints</strong> (cables / bars) in varied layouts (ceiling, wall pull, floor pull, corner brackets).
            </div>
          </div>
        </div>
      </div>
      <footer>
        <span class="muted">You can generate a fresh random set any time.</span>
        <div><button class="primary" id="startBtn">Start worksheet</button></div>
      </footer>
    </div>
  </div>

  <div id="errBanner"></div>
  <noscript><div style="margin:0.6rem auto;max-width:980px;color:#b91c1c;background:#fee;border:2px solid #e11d48;padding:.6rem;border-radius:12px;font-weight:800">This worksheet needs JavaScript enabled.</div></noscript>

<script>
'use strict';

window.addEventListener('error', (e) => {
  const b = document.getElementById('errBanner');
  b.textContent = 'Error: ' + (e.message || 'Unknown script error');
  b.style.display = 'block';
});

window.addEventListener('DOMContentLoaded', () => {

  /* ========= Marking tolerance ========= */
  const MARK_TOL = 2.00;                 // accept within ±2.00
  const STEP_SCALE = 100;                // 0.01 resolution
  const MARK_TOL_100 = Math.round(MARK_TOL * STEP_SCALE); // 200

  /* ========= Helpers ========= */
  const rndInt=(m,M)=>Math.floor(Math.random()*(M-m+1))+m;
  const pick=arr=>arr[Math.floor(Math.random()*arr.length)];
  const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
  const rndf=(min,max,dp=2)=>+((Math.random()*(max-min)+min).toFixed(dp));
  const deg2rad=d=>d*Math.PI/180;

  // Robust rounding (symmetric, stable)
  const roundInt = (v, dp) => {
    const f = 10 ** dp;
    const sign = v < 0 ? -1 : 1;
    return sign * Math.round((Math.abs(v) + 1e-12) * f);
  };
  const round2 = x => roundInt(+x, 2) / 100;

  // Convert to integer hundredths (exact 0.01-step marking)
  const toHundredths = x => roundInt(+x, 2);

  // Display numbers: 2 dp unless whole number (no trailing .00 needed)
  function fmt(x){
    if(!isFinite(x)) return '—';
    const r = round2(x);
    const isInt = Math.abs(r - Math.round(r)) < 1e-9;
    return isInt ? String(Math.round(r)) : r.toFixed(2);
  }

  const parseNum = (input) => {
    const raw = (typeof input === 'string' ? input : (input?.value ?? ''))
      .toString()
      .trim()
      .replace(/,/g,'.');
    const x = parseFloat(raw);
    return isFinite(x)?x:NaN;
  };

  const secsToMMSS=s=>{const m=Math.floor(s/60), ss=String(s%60).padStart(2,'0'); return `${m}:${ss}`;};
  const unit = (u) => ({ kN:'kN' }[u]||u);

  // TRUE ±2.00 tolerance checked at 0.01 resolution (no floats)
  function withinTolerance(stu, expected){
    if(!isFinite(stu) || !isFinite(expected)) return false;
    const s100 = toHundredths(stu);
    const e100 = toHundredths(expected);
    return Math.abs(s100 - e100) <= MARK_TOL_100;
  }

  /* ========= Diagram geometry constraints (keep members visible) ========= */
  const SUR = {
    xMin: 90, xMax: 810,
    yMinWall: 90, yMaxWall: 470,
    yCeil: 120, yFloor: 440,
    xWallL: 160, xWallR: 740
  };

  function anchorOn(surface, jx, jy, angleRad){
    const dx = Math.cos(angleRad);
    const dy = -Math.sin(angleRad); // SVG y-down

    let t, x, y;

    if(surface === 'ceiling'){
      if(dy >= -1e-6) return null; // must point upward
      t = (SUR.yCeil - jy) / dy;
      if(!(t > 0)) return null;
      x = jx + t*dx; y = SUR.yCeil;
      if(x < SUR.xMin || x > SUR.xMax) return null;
      return {x, y};
    }

    if(surface === 'floor'){
      if(dy <= 1e-6) return null; // must point downward
      t = (SUR.yFloor - jy) / dy;
      if(!(t > 0)) return null;
      x = jx + t*dx; y = SUR.yFloor;
      if(x < SUR.xMin || x > SUR.xMax) return null;
      return {x, y};
    }

    if(surface === 'wallLeft'){
      if(dx >= -1e-6) return null; // must point left
      t = (SUR.xWallL - jx) / dx;
      if(!(t > 0)) return null;
      y = jy + t*dy; x = SUR.xWallL;
      if(y < SUR.yMinWall || y > SUR.yMaxWall) return null;
      return {x, y};
    }

    if(surface === 'wallRight'){
      if(dx <= 1e-6) return null; // must point right
      t = (SUR.xWallR - jx) / dx;
      if(!(t > 0)) return null;
      y = jy + t*dy; x = SUR.xWallR;
      if(y < SUR.yMinWall || y > SUR.yMaxWall) return null;
      return {x, y};
    }

    return null;
  }

  /* ========= SVG base ========= */
  function figWrap(viewW, viewH, inner){
    return `<svg class="fig" viewBox="0 0 ${viewW} ${viewH}" xmlns="http://www.w3.org/2000/svg"
      role="img" aria-label="diagram" preserveAspectRatio="xMidYMid meet" style="overflow:visible">
      <defs>
        <!-- SMALLER arrowheads -->
        <marker id="arrRed" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="4.2" markerHeight="4.2" orient="auto">
          <path d="M 0 0 L 10 5 L 0 10 z" fill="#b91c1c"/>
        </marker>

        <pattern id="hatch" patternUnits="userSpaceOnUse" width="10" height="10" patternTransform="rotate(30)">
          <line x1="0" y1="0" x2="0" y2="10" stroke="#cbd5e1" stroke-width="3"/>
        </pattern>

        <filter id="softShadow" x="-20%" y="-20%" width="140%" height="140%">
          <feDropShadow dx="0" dy="2" stdDeviation="2" flood-color="#0f172a" flood-opacity="0.14"/>
        </filter>

        <style>
          .lbl{
            font:900 15px/1.1 Inter, system-ui; fill:#2c3477;
            paint-order:stroke fill; stroke:#fff; stroke-width:5px;
          }
          .small{
            font:800 13px/1.1 Inter, system-ui; fill:#1f2a44;
            paint-order:stroke fill; stroke:#fff; stroke-width:5px;
          }
          .note{
            font:800 12px/1.1 Inter, system-ui; fill:#374151;
            paint-order:stroke fill; stroke:#fff; stroke-width:5px;
          }

          /* Surfaces */
          .topBeam{stroke:#0f172a;stroke-width:12;stroke-linecap:round;filter:url(#softShadow)}
          .surfaceLine{stroke:#94a3b8;stroke-width:2.6}
          .surfaceBlock{fill:url(#hatch);stroke:#94a3b8;stroke-width:2}

          /* Joint + anchors */
          .anchor{fill:#0f172a}
          .joint{fill:#111827}
          .ring{fill:none;stroke:#111827;stroke-width:3}

          /* Members (bars/rods) */
          .memberHalo{stroke:#ffffff;stroke-width:10;stroke-linecap:round}
          .memberLine{stroke:#111827;stroke-width:7;stroke-linecap:round;filter:url(#softShadow)}

          /* Cables (outlined so they NEVER disappear) */
          .cableHalo{stroke:#ffffff;stroke-width:8;stroke-linecap:round}
          .cable{stroke:#0f172a;stroke-width:4.2;stroke-linecap:round}

          /* Forces */
          .forcePoint{stroke:#b91c1c;stroke-width:3.8;stroke-linecap:round;marker-end:url(#arrRed)}

          /* Reference + angles */
          .refLine{stroke:#00c2ff;stroke-width:2.2;stroke-dasharray:8 7}
          .arc{fill:none;stroke:#94a3b8;stroke-width:2.0}
          .leader{stroke:#94a3b8;stroke-width:1.6;stroke-linecap:round}
        </style>
      </defs>
      ${inner}
    </svg>`;
  }

  function arcPath(jx,jy,r,a1,a2){
    const x1 = jx + r*Math.cos(a1);
    const y1 = jy - r*Math.sin(a1);
    const x2 = jx + r*Math.cos(a2);
    const y2 = jy - r*Math.sin(a2);
    let d = a2 - a1;
    while(d > Math.PI) d -= 2*Math.PI;
    while(d < -Math.PI) d += 2*Math.PI;
    const largeArc = 0;
    const sweep = (d > 0) ? 0 : 1; // SVG y-down
    return `M ${x1} ${y1} A ${r} ${r} 0 ${largeArc} ${sweep} ${x2} ${y2}`;
  }

  function memberLabel(jx,jy,ax,ay,text){
    const mx = (jx+ax)/2, my=(jy+ay)/2;
    const vx = ax-jx, vy=ay-jy;
    const L = Math.max(1, Math.hypot(vx,vy));
    const nx = -vy/L, ny = vx/L;
    const tx = mx + 14*nx, ty = my + 14*ny;
    return `
      <line x1="${mx}" y1="${my}" x2="${tx}" y2="${ty-4}" class="leader"/>
      <text x="${tx}" y="${ty}" text-anchor="middle" class="small">${text}</text>
    `;
  }

  function svgTwoMemberJoint(opts){
    const w=900, h=520;

    const env = opts.env;
    const title = opts.title || 'Two-member joint';
    const subtitle = opts.subtitle || 'Find the required member force';

    const jx = opts.jx ?? 450;
    const jy = opts.jy ?? 280;

    const refDeg = opts.refDeg;
    const th1Deg  = opts.th1Deg;
    const th2Deg  = opts.th2Deg;
    const P = opts.P;
    const forceLabel = opts.forceLabel || 'P';

    const member1Kind = opts.member1Kind || 'cable';
    const member2Kind = opts.member2Kind || 'cable';

    const xWallL = SUR.xWallL, xWallR = SUR.xWallR;
    const yCeil  = SUR.yCeil,  yFloor = SUR.yFloor;

    const ref = deg2rad(refDeg);
    const a1  = deg2rad(refDeg + th1Deg);
    const a2  = deg2rad(refDeg - th2Deg);
    const f   = deg2rad(refDeg + 180);

    const hasCeil  = (env==='ceiling' || env==='cornerTL' || env==='cornerTR');
    const hasFloor = (env==='floor'   || env==='cornerBL' || env==='cornerBR');
    const hasWL    = (env==='wallLeft'|| env==='cornerTL' || env==='cornerBL');
    const hasWR    = (env==='wallRight'||env==='cornerTR' || env==='cornerBR');

    const A1 = opts.A1 ?? {x: jx + 230*Math.cos(a1), y: jy - 230*Math.sin(a1)};
    const A2 = opts.A2 ?? {x: jx + 230*Math.cos(a2), y: jy - 230*Math.sin(a2)};

    const Lref = 170, Lf = 160;
    const rx = jx + Lref*Math.cos(ref);
    const ry = jy - Lref*Math.sin(ref);
    const fx = jx + Lf*Math.cos(f);
    const fy = jy - Lf*Math.sin(f);

    const rArc = 62;
    const arc1 = arcPath(jx,jy,rArc,ref,a1);
    const arc2 = arcPath(jx,jy,rArc,ref,a2);

    const mid1 = ref + deg2rad(th1Deg/2);
    const mid2 = ref - deg2rad(th2Deg/2);

    const t1x = jx + (rArc+22)*Math.cos(mid1);
    const t1y = jy - (rArc+22)*Math.sin(mid1);

    const t2x = jx + (rArc+22)*Math.cos(mid2);
    const t2y = jy - (rArc+22)*Math.sin(mid2);

    let surfaces = '';
    if(hasCeil){
      surfaces += `<line x1="${SUR.xMin}" y1="${yCeil}" x2="${SUR.xMax}" y2="${yCeil}" class="topBeam"/>`;
    }
    if(hasFloor){
      surfaces += `
        <line x1="${SUR.xMin}" y1="${yFloor}" x2="${SUR.xMax}" y2="${yFloor}" class="surfaceLine"/>
        <rect x="${SUR.xMin}" y="${yFloor}" width="${SUR.xMax-SUR.xMin}" height="22" class="surfaceBlock"/>
      `;
    }
    if(hasWL){
      surfaces += `
        <line x1="${xWallL}" y1="${SUR.yMinWall}" x2="${xWallL}" y2="${SUR.yMaxWall}" class="surfaceLine"/>
        <rect x="${xWallL-22}" y="${SUR.yMinWall}" width="22" height="${SUR.yMaxWall-SUR.yMinWall}" class="surfaceBlock"/>
      `;
    }
    if(hasWR){
      surfaces += `
        <line x1="${xWallR}" y1="${SUR.yMinWall}" x2="${xWallR}" y2="${SUR.yMaxWall}" class="surfaceLine"/>
        <rect x="${xWallR}" y="${SUR.yMinWall}" width="22" height="${SUR.yMaxWall-SUR.yMinWall}" class="surfaceBlock"/>
      `;
    }

    function drawMember(ax, ay, kind){
      if(kind === 'bar'){
        return `
          <line x1="${jx}" y1="${jy}" x2="${ax}" y2="${ay}" class="memberHalo"/>
          <line x1="${jx}" y1="${jy}" x2="${ax}" y2="${ay}" class="memberLine"/>
        `;
      }
      return `
        <line x1="${jx}" y1="${jy}" x2="${ax}" y2="${ay}" class="cableHalo"/>
        <line x1="${jx}" y1="${jy}" x2="${ax}" y2="${ay}" class="cable"/>
      `;
    }

    return figWrap(w,h,`
      <text x="${w/2}" y="34" text-anchor="middle" class="lbl">${title}</text>
      <text x="${w/2}" y="58" text-anchor="middle" class="note">${subtitle}</text>

      ${surfaces}

      <line x1="${jx}" y1="${jy}" x2="${rx}" y2="${ry}" class="refLine"/>
      <text x="${rx}" y="${ry-10}" text-anchor="middle" class="note">ref</text>

      ${drawMember(A1.x, A1.y, member1Kind)}
      ${drawMember(A2.x, A2.y, member2Kind)}

      <circle cx="${A1.x}" cy="${A1.y}" r="9" class="anchor"/>
      <circle cx="${A2.x}" cy="${A2.y}" r="9" class="anchor"/>

      <circle cx="${jx}" cy="${jy}" r="12" class="joint"/>
      <circle cx="${jx}" cy="${jy}" r="18" class="ring" opacity="0.45"/>

      <line x1="${jx}" y1="${jy}" x2="${fx}" y2="${fy}" class="forcePoint"/>
      <text x="${fx}" y="${fy-12}" text-anchor="middle" class="small">${forceLabel} = ${fmt(P)} kN</text>

      <path d="${arc1}" class="arc"/>
      <path d="${arc2}" class="arc"/>
      <text x="${t1x}" y="${t1y}" text-anchor="middle" class="small">θ₁=${Math.round(th1Deg)}°</text>
      <text x="${t2x}" y="${t2y}" text-anchor="middle" class="small">θ₂=${Math.round(th2Deg)}°</text>

      ${memberLabel(jx,jy,A1.x,A1.y,'Member 1')}
      ${memberLabel(jx,jy,A2.x,A2.y,'Member 2')}
    `);
  }

  /* ========= Solvers ========= */
  function solve2x2(a11,a12,b1,a21,a22,b2){
    const det = a11*a22 - a12*a21;
    if(Math.abs(det) < 1e-12) return null;
    const x = (b1*a22 - a12*b2) / det;
    const y = (a11*b2 - b1*a21) / det;
    if(!isFinite(x) || !isFinite(y)) return null;
    return { x, y, det };
  }

  function solveTwoMember(refDeg, th1Deg, th2Deg, P){
    // math coords: x right, y up. External force acts opposite to ref line.
    const a1 = deg2rad(refDeg + th1Deg);
    const a2 = deg2rad(refDeg - th2Deg);
    const f  = deg2rad(refDeg + 180);

    const u1x = Math.cos(a1), u1y = Math.sin(a1);
    const u2x = Math.cos(a2), u2y = Math.sin(a2);

    const Fx = P*Math.cos(f);
    const Fy = P*Math.sin(f);

    // u1*T1 + u2*T2 + F = 0  =>  [u1 u2][T] = -F
    const sol = solve2x2(u1x, u2x, -Fx, u1y, u2y, -Fy);
    if(!sol) return null;

    return { T1: sol.x, T2: sol.y };
  }

  function genAnglesWithAnchors(refDeg, P, minAng, maxAng, jx, jy, surf1, surf2){
    // Passes: start strict, then slightly relax if needed (prevents ever returning fake 0 answers)
    const passes = [
      { min:minAng, max:maxAng, maxT:260, tries:1400 },
      { min:Math.max(10, minAng-6), max:Math.min(70, maxAng+10), maxT:320, tries:2200 },
      { min:10, max:70, maxT:420, tries:3200 }
    ];

    for(const pass of passes){
      for(let i=0;i<pass.tries;i++){
        const th1 = rndInt(pass.min, pass.max);
        const th2 = rndInt(pass.min, pass.max);

        const sol = solveTwoMember(refDeg, th1, th2, P);
        if(!sol) continue;
        if(!(sol.T1 > 0 && sol.T2 > 0)) continue;
        if(sol.T1 > pass.maxT || sol.T2 > pass.maxT) continue;

        const a1 = deg2rad(refDeg + th1);
        const a2 = deg2rad(refDeg - th2);

        const A1 = anchorOn(surf1, jx, jy, a1);
        const A2 = anchorOn(surf2, jx, jy, a2);
        if(!A1 || !A2) continue;

        const L1 = Math.hypot(A1.x - jx, A1.y - jy);
        const L2 = Math.hypot(A2.x - jx, A2.y - jy);
        if(L1 < 95 || L2 < 95) continue;

        const sep = Math.hypot(A1.x - A2.x, A1.y - A2.y);
        if(sep < 28) continue;

        return { th1, th2, T1: sol.T1, T2: sol.T2, A1, A2 };
      }
    }

    // Deterministic sweep (final guarantee) — still respects geometry.
    for(let th1=10; th1<=70; th1++){
      for(let th2=10; th2<=70; th2++){
        const sol = solveTwoMember(refDeg, th1, th2, P);
        if(!sol) continue;
        if(!(sol.T1 > 0 && sol.T2 > 0)) continue;

        const a1 = deg2rad(refDeg + th1);
        const a2 = deg2rad(refDeg - th2);

        const A1 = anchorOn(surf1, jx, jy, a1);
        const A2 = anchorOn(surf2, jx, jy, a2);
        if(!A1 || !A2) continue;

        const L1 = Math.hypot(A1.x - jx, A1.y - jy);
        const L2 = Math.hypot(A2.x - jx, A2.y - jy);
        if(L1 < 70 || L2 < 70) continue;

        return { th1, th2, T1: sol.T1, T2: sol.T2, A1, A2 };
      }
    }

    // If we *ever* get here, something is deeply off — throw a clear error instead of fake answers.
    throw new Error('Could not generate a valid two-member joint (angles/anchors) for this configuration.');
  }

  /* ========= Question generators (TWO MEMBERS ONLY) ========= */

  function qCeiling_HangingWeight(){
    const P = rndf(6, 55, 2);
    const refDeg = 90;
    const jx=450, jy=340;

    const g = genAnglesWithAnchors(refDeg, P, 20, 55, jx, jy, 'ceiling', 'ceiling');

    const ask = pick(['T1','T2']);
    const want = (ask==='T1') ? g.T1 : g.T2;

    const svg = svgTwoMemberJoint({
      env:'ceiling',
      jx, jy,
      refDeg,
      th1Deg:g.th1,
      th2Deg:g.th2,
      A1:g.A1, A2:g.A2,
      P,
      forceLabel:'W',
      member1Kind:'cable',
      member2Kind:'cable',
      title:'Hanging load supported by two cables',
      subtitle:`Find the ${ask==='T1'?'tension in Member 1':'tension in Member 2'}`
    });

    return {
      title:'Two‑cable joint (hanging load)',
      statementHTML:`
        A joint is supported by <strong>two members</strong> and is in <strong>static equilibrium</strong>.
        Angles <strong>θ₁</strong> and <strong>θ₂</strong> are measured from the <strong>dashed reference line</strong>.
        The load <strong>W</strong> acts opposite to the dashed line as shown.
        <br><br>
        Find the <strong>${ask==='T1'?'tension in Member 1':'tension in Member 2'}</strong>.
        ${svg}
      `,
      unitOut: unit('kN'),
      check:()=>({ val: want })
    };
  }

  function qWallLeft_PullRight(){
    const P = rndf(8, 75, 2);
    const refDeg = 180;
    const jx=420, jy=270;

    const g = genAnglesWithAnchors(refDeg, P, 20, 38, jx, jy, 'wallLeft', 'wallLeft');

    const ask = pick(['T1','T2']);
    const want = (ask==='T1') ? g.T1 : g.T2;

    const svg = svgTwoMemberJoint({
      env:'wallLeft',
      jx, jy,
      refDeg,
      th1Deg:g.th1,
      th2Deg:g.th2,
      A1:g.A1, A2:g.A2,
      P,
      forceLabel:'P',
      member1Kind:'cable',
      member2Kind:'bar',
      title:'Wall‑mounted joint pulled to the right',
      subtitle:`Find the ${ask==='T1'?'tension in Member 1':'tension in Member 2'}`
    });

    return {
      title:'Wall joint — pull to the right (cable + bar)',
      statementHTML:`
        A joint is attached to a wall by <strong>two members</strong> (a cable and a bar) and is in <strong>static equilibrium</strong>.
        The <strong>dashed</strong> line is the reference for <strong>θ₁</strong> and <strong>θ₂</strong>.
        The applied force <strong>P</strong> acts opposite to that dashed line (as shown).
        <br><br>
        Find the <strong>${ask==='T1'?'tension in Member 1':'tension in Member 2'}</strong>.
        ${svg}
      `,
      unitOut: unit('kN'),
      check:()=>({ val: want })
    };
  }

  function qWallRight_PullLeft(){
    const P = rndf(8, 75, 2);
    const refDeg = 0;
    const jx=480, jy=270;

    const g = genAnglesWithAnchors(refDeg, P, 20, 38, jx, jy, 'wallRight', 'wallRight');

    const ask = pick(['T1','T2']);
    const want = (ask==='T1') ? g.T1 : g.T2;

    const svg = svgTwoMemberJoint({
      env:'wallRight',
      jx, jy,
      refDeg,
      th1Deg:g.th1,
      th2Deg:g.th2,
      A1:g.A1, A2:g.A2,
      P,
      forceLabel:'P',
      member1Kind:'bar',
      member2Kind:'bar',
      title:'Wall‑mounted joint pulled to the left',
      subtitle:`Find the ${ask==='T1'?'tension in Member 1':'tension in Member 2'}`
    });

    return {
      title:'Wall joint — pull to the left (two bars)',
      statementHTML:`
        A joint is supported by <strong>two members</strong> (bars/rods) attached to a wall and is in <strong>static equilibrium</strong>.
        Angles <strong>θ₁</strong> and <strong>θ₂</strong> are measured from the <strong>dashed reference line</strong>.
        The applied force <strong>P</strong> acts opposite to that dashed line (as shown).
        <br><br>
        Find the <strong>${ask==='T1'?'tension in Member 1':'tension in Member 2'}</strong>.
        ${svg}
      `,
      unitOut: unit('kN'),
      check:()=>({ val: want })
    };
  }

  function qFloor_PullUp(){
    const P = rndf(8, 80, 2);
    const refDeg = 270;
    const jx=450, jy=190;

    const g = genAnglesWithAnchors(refDeg, P, 20, 55, jx, jy, 'floor', 'floor');

    const ask = pick(['T1','T2']);
    const want = (ask==='T1') ? g.T1 : g.T2;

    const svg = svgTwoMemberJoint({
      env:'floor',
      jx, jy,
      refDeg,
      th1Deg:g.th1,
      th2Deg:g.th2,
      A1:g.A1, A2:g.A2,
      P,
      forceLabel:'P',
      member1Kind:'bar',
      member2Kind:'cable',
      title:'Joint pulled upward (floor anchors)',
      subtitle:`Find the ${ask==='T1'?'tension in Member 1':'tension in Member 2'}`
    });

    return {
      title:'Floor joint — pull upward (bar + cable)',
      statementHTML:`
        A joint is anchored to the floor by <strong>two members</strong> and is in <strong>static equilibrium</strong>.
        Angles <strong>θ₁</strong> and <strong>θ₂</strong> are measured from the <strong>dashed reference line</strong>.
        The applied force <strong>P</strong> acts opposite to that dashed line (as shown).
        <br><br>
        Find the <strong>${ask==='T1'?'tension in Member 1':'tension in Member 2'}</strong>.
        ${svg}
      `,
      unitOut: unit('kN'),
      check:()=>({ val: want })
    };
  }

  function qCornerTopLeft_Oblique(){
    const P = rndf(8, 70, 2);
    const refDeg = 135;
    const jx=660, jy=360;

    const g = genAnglesWithAnchors(refDeg, P, 20, 45, jx, jy, 'wallLeft', 'ceiling');

    const ask = pick(['T1','T2']);
    const want = (ask==='T1') ? g.T1 : g.T2;

    const svg = svgTwoMemberJoint({
      env:'cornerTL',
      jx, jy,
      refDeg,
      th1Deg:g.th1,
      th2Deg:g.th2,
      A1:g.A1, A2:g.A2,
      P,
      forceLabel:'P',
      member1Kind:'bar',
      member2Kind:'cable',
      title:'Corner‑braced joint (wall + ceiling)',
      subtitle:`Find the ${ask==='T1'?'tension in Member 1':'tension in Member 2'}`
    });

    return {
      title:'Corner joint — oblique load (wall + ceiling)',
      statementHTML:`
        A joint is braced by <strong>two members</strong> to a <strong>wall/ceiling corner</strong> and is in <strong>static equilibrium</strong>.
        Angles <strong>θ₁</strong> and <strong>θ₂</strong> are measured from the <strong>dashed reference line</strong>.
        The applied force <strong>P</strong> acts opposite to that dashed line (as shown).
        <br><br>
        Find the <strong>${ask==='T1'?'tension in Member 1':'tension in Member 2'}</strong>.
        ${svg}
      `,
      unitOut: unit('kN'),
      check:()=>({ val: want })
    };
  }

  function qCornerBottomLeft_Oblique(){
    const P = rndf(8, 70, 2);
    const refDeg = 225;
    const jx=650, jy=170;

    const g = genAnglesWithAnchors(refDeg, P, 20, 45, jx, jy, 'floor', 'wallLeft');

    const ask = pick(['T1','T2']);
    const want = (ask==='T1') ? g.T1 : g.T2;

    const svg = svgTwoMemberJoint({
      env:'cornerBL',
      jx, jy,
      refDeg,
      th1Deg:g.th1,
      th2Deg:g.th2,
      A1:g.A1, A2:g.A2,
      P,
      forceLabel:'P',
      member1Kind:'bar',
      member2Kind:'bar',
      title:'Corner‑anchored joint (wall + floor)',
      subtitle:`Find the ${ask==='T1'?'tension in Member 1':'tension in Member 2'}`
    });

    return {
      title:'Corner joint — oblique upward pull (wall + floor)',
      statementHTML:`
        A joint is anchored by <strong>two members</strong> to a <strong>wall/floor corner</strong> and is in <strong>static equilibrium</strong>.
        Angles <strong>θ₁</strong> and <strong>θ₂</strong> are measured from the <strong>dashed reference line</strong>.
        The applied force <strong>P</strong> acts opposite to that dashed line (as shown).
        <br><br>
        Find the <strong>${ask==='T1'?'tension in Member 1':'tension in Member 2'}</strong>.
        ${svg}
      `,
      unitOut: unit('kN'),
      check:()=>({ val: want })
    };
  }

  function qCornerTopRight_Oblique(){
    const P = rndf(8, 70, 2);
    const refDeg = 45;
    const jx=240, jy=360;

    const g = genAnglesWithAnchors(refDeg, P, 20, 45, jx, jy, 'ceiling', 'wallRight');

    const ask = pick(['T1','T2']);
    const want = (ask==='T1') ? g.T1 : g.T2;

    const svg = svgTwoMemberJoint({
      env:'cornerTR',
      jx, jy,
      refDeg,
      th1Deg:g.th1,
      th2Deg:g.th2,
      A1:g.A1, A2:g.A2,
      P,
      forceLabel:'P',
      member1Kind:'cable',
      member2Kind:'cable',
      title:'Corner‑braced joint (ceiling + wall)',
      subtitle:`Find the ${ask==='T1'?'tension in Member 1':'tension in Member 2'}`
    });

    return {
      title:'Corner joint — oblique load (ceiling + wall)',
      statementHTML:`
        A joint is braced by <strong>two cables</strong> to a <strong>ceiling/wall corner</strong> and is in <strong>static equilibrium</strong>.
        Angles <strong>θ₁</strong> and <strong>θ₂</strong> are measured from the <strong>dashed reference line</strong>.
        The applied force <strong>P</strong> acts opposite to that dashed line (as shown).
        <br><br>
        Find the <strong>${ask==='T1'?'tension in Member 1':'tension in Member 2'}</strong>.
        ${svg}
      `,
      unitOut: unit('kN'),
      check:()=>({ val: want })
    };
  }

  function qCornerBottomRight_Oblique(){
    const P = rndf(8, 70, 2);
    const refDeg = 315;
    const jx=250, jy=170;

    const g = genAnglesWithAnchors(refDeg, P, 20, 45, jx, jy, 'wallRight', 'floor');

    const ask = pick(['T1','T2']);
    const want = (ask==='T1') ? g.T1 : g.T2;

    const svg = svgTwoMemberJoint({
      env:'cornerBR',
      jx, jy,
      refDeg,
      th1Deg:g.th1,
      th2Deg:g.th2,
      A1:g.A1, A2:g.A2,
      P,
      forceLabel:'P',
      member1Kind:'bar',
      member2Kind:'cable',
      title:'Corner‑anchored joint (wall + floor)',
      subtitle:`Find the ${ask==='T1'?'tension in Member 1':'tension in Member 2'}`
    });

    return {
      title:'Corner joint — oblique upward pull (wall + floor)',
      statementHTML:`
        A joint is anchored by <strong>two members</strong> (bar + cable) to a <strong>wall/floor corner</strong> and is in <strong>static equilibrium</strong>.
        Angles <strong>θ₁</strong> and <strong>θ₂</strong> are measured from the <strong>dashed reference line</strong>.
        The applied force <strong>P</strong> acts opposite to that dashed line (as shown).
        <br><br>
        Find the <strong>${ask==='T1'?'tension in Member 1':'tension in Member 2'}</strong>.
        ${svg}
      `,
      unitOut: unit('kN'),
      check:()=>({ val: want })
    };
  }

  const GENERATORS = [
    qCeiling_HangingWeight,
    qWallLeft_PullRight,
    qWallRight_PullLeft,
    qFloor_PullUp,
    qCornerTopLeft_Oblique,
    qCornerBottomLeft_Oblique,
    qCornerTopRight_Oblique,
    qCornerBottomRight_Oblique
  ];

  /* ========= App state + logic ========= */
  let QUESTIONS=[], BATCH=10, idx=0, score=0;
  let nameStr='Student', mode='timed', timeLeft=0, timerId=null, target=0, correctSoFar=0, unlimited=false;
  let currentQ=null;

  const el = id=>document.getElementById(id);
  const $qCard=el('qCard');
  const $endCard=el('endCard');
  const $qTitle=el('qTitle'), $statement=el('statement');
  const $progress=el('progress');
  const $ansVal=el('ansVal'), $unitOut=el('unitOut'), $markAns=el('markAns'), $fbAns=el('fbAns');
  const $nextBtn=el('nextBtn');
  const $sumName=el('sumName'), $sumMode=el('sumMode'), $sumScore=el('sumScore'), $sumTime=el('sumTime');
  const $scoreTopVal=el('scoreTopVal'), $modeTxt=el('modeTxt'), $timeTxt=el('timeTxt');

  function buildSet(n){
    const gens=[...GENERATORS];
    const qs=[];
    for(let i=0;i<n;i++){
      const g = gens.length
        ? gens.splice(Math.floor(Math.random()*gens.length),1)[0]
        : GENERATORS[Math.floor(Math.random()*(GENERATORS.length))];

      // Safety: never allow a broken/NaN question into the set
      let q=null;
      for(let tries=0; tries<25; tries++){
        q = g();
        const test = q?.check?.().val;
        if(isFinite(test) && test > 0) break;
        q = null;
      }
      if(!q) q = qCeiling_HangingWeight();

      qs.push(q);
    }
    return qs;
  }

  function updateTop(){
    el('whoName').textContent = nameStr || 'Student';
    $modeTxt.textContent = mode==='timed' ? 'Timed' : 'Target';
    $scoreTopVal.textContent = `${score} / ${idx}`;
    $timeTxt.textContent = (mode==='timed' && !unlimited) ? secsToMMSS(timeLeft) : '—';
  }

  function startTimer(){
    if(mode!=='timed' || unlimited) return;
    clearInterval(timerId);
    timerId = setInterval(()=>{
      timeLeft = Math.max(0, timeLeft-1);
      $timeTxt.textContent = secsToMMSS(timeLeft);
      if(timeLeft===0){
        clearInterval(timerId);
        finish('Time’s up!');
      }
    },1000);
  }

  function startWorksheet(){
    BATCH = parseInt(el('qtyInput').value,10);
    QUESTIONS = buildSet(BATCH);
    idx=0; score=0; correctSoFar=0;
    $endCard.style.display='none';
    $qCard.style.display='block';
    el('globalHint').style.display='block';
    renderQ();
    updateTop();
    if(mode==='timed'){ startTimer(); }
  }

  function finish(message='Well done!'){
    clearInterval(timerId);
    $qCard.style.display='none';
    el('globalHint').style.display='none';
    $endCard.style.display='block';
    el('endMsg').textContent = message;
    $sumName.textContent = nameStr || 'Student';
    $sumMode.textContent = ($modeTxt.textContent);
    $sumScore.textContent = `${score} / ${idx}`;
    const tlimitRaw = parseInt(document.querySelector('input[name="tlimit"]:checked')?.value||'0',10);
    const setTime = (mode==='timed' && !unlimited) ? tlimitRaw : 0;
    const usedSecs = (mode==='timed' && !unlimited) ? (setTime - timeLeft) : 0;
    $sumTime.textContent = (mode==='timed' && !unlimited) ? secsToMMSS(usedSecs) : '—';
  }

  function clearFeedback(){
    $markAns.textContent=''; $markAns.className='marker'; $fbAns.textContent='';
  }
  function progressText(){
    return (mode==='timed') ? `Question ${idx+1}` : `Question ${idx+1} · Target ${correctSoFar}/${target}`;
  }

  function renderQ(){
    const local = idx % QUESTIONS.length;
    currentQ = QUESTIONS[local];
    $progress.textContent = progressText();
    $qTitle.textContent = currentQ.title;
    $statement.innerHTML = currentQ.statementHTML;
    $unitOut.textContent = currentQ.unitOut;
    $ansVal.value='';
    $ansVal.disabled=false;
    clearFeedback();
    $nextBtn.disabled = true;
  }

  function checkCurrent(){
    const { val } = currentQ.check();

    // Expected value is defined as “rounded to 2 d.p.” for the mark scheme
    const expected100 = toHundredths(val);
    const expected = expected100 / 100;

    const stu = parseNum($ansVal);

    let ok=false;
    if(isFinite(stu) && withinTolerance(stu, expected)){
      $markAns.textContent='✓'; $markAns.className='marker ok'; $fbAns.textContent='';
      ok=true;
    }else if(!isNaN(stu)){
      const lo = fmt(expected - MARK_TOL);
      const hi = fmt(expected + MARK_TOL);
      $markAns.textContent='✗'; $markAns.className='marker no';
      $fbAns.innerHTML = `Ans: <span class="ans">${fmt(expected)} ${currentQ.unitOut}</span> <span style="color:#55607a">(accepted: ${lo} to ${hi})</span>`;
    }else{
      $markAns.textContent='✗'; $markAns.className='marker no';
      $fbAns.textContent = 'Please enter a number (e.g. 12.34).';
    }

    idx++;
    if(ok){ score++; correctSoFar++; }
    $scoreTopVal.textContent = `${score} / ${idx}`;
    $ansVal.disabled=true;
    $nextBtn.disabled=false;

    if(mode==='target' && correctSoFar>=target){ finish('Target achieved!'); return; }
    if(idx % QUESTIONS.length === 0){ QUESTIONS = buildSet(BATCH); }
  }

  function nextQ(){ renderQ(); updateTop(); }

  document.getElementById('checkBtn').addEventListener('click', checkCurrent);
  document.getElementById('nextBtn').addEventListener('click', nextQ);
  document.getElementById('newBtn').addEventListener('click', ()=>{ document.getElementById('startModal').style.display='flex'; });

  document.addEventListener('keydown', (e)=>{
    if(e.key==='Enter' && !$nextBtn.disabled){ nextQ(); }
    else if(e.key==='Enter' && $nextBtn.disabled){ checkCurrent(); }
  });

  function updateModeFields(){
    const modeEl = document.querySelector('input[name="mode"]:checked');
    const modeVal = modeEl ? modeEl.value : 'timed';
    document.getElementById('timedField').style.display = (modeVal==='timed') ? '' : 'none';
    document.getElementById('targetField').style.display = (modeVal==='target') ? '' : 'none';
  }
  document.querySelectorAll('input[name="mode"]').forEach(r=>r.addEventListener('change', updateModeFields));

  document.getElementById('startBtn').addEventListener('click', ()=>{
    const nameInput = document.getElementById('nameInput');
    nameInput.value = nameInput.value.trim();
    nameStr = nameInput.value || 'Student';

    const picked = document.querySelector('input[name="mode"]:checked');
    mode = picked ? picked.value : 'timed';
    unlimited = false;

    if(mode==='timed'){
      const tSel = parseInt(document.querySelector('input[name="tlimit"]:checked')?.value||'1200',10);
      unlimited = (tSel===0);
      timeLeft = unlimited ? 0 : tSel;
    } else {
      timeLeft = 0;
    }

    if(mode==='target'){
      target = clamp(parseInt(document.getElementById('targetInput').value,10)||10,1,1000000);
    } else { target = 0; }

    document.getElementById('startModal').style.display='none';
    document.getElementById('modeTxt').textContent = mode==='timed' ? 'Timed' : 'Target';
    if(mode==='timed' && unlimited){ document.getElementById('timeTxt').textContent='—'; }
    startWorksheet();
  });

  document.getElementById('restartBtn').addEventListener('click', ()=>{ document.getElementById('startModal').style.display='flex'; });
  updateModeFields();

  document.getElementById('fsBtn').addEventListener('click', ()=>{
    if(!document.fullscreenElement){ document.documentElement.requestFullscreen?.(); }
    else{ document.exitFullscreen?.(); }
  });
  document.addEventListener('fullscreenchange', ()=>{
    document.getElementById('fsBtn').textContent = document.fullscreenElement ? '✕ Exit full screen' : '⛶ Full screen';
  });

  document.getElementById('startModal').style.display='flex';
});
</script>

</body>
</html>
